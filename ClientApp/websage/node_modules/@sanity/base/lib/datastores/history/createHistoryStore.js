"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createHistoryStore;

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _rxjs = require("rxjs");

var _transactionCollator = require("@sanity/transaction-collator");

var _operators = require("rxjs/operators");

var _draftUtils = require("../../util/draftUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var documentRevisionCache = Object.create(null);

var compileTransactions = (acc, curr) => {
  if (acc[curr.id]) {
    acc[curr.id].mutations = acc[curr.id].mutations.concat(curr.mutations);
    acc[curr.id].timestamp = curr.timestamp;
  } else {
    acc[curr.id] = curr;
  }

  return acc;
};

var ndjsonToArray = ndjson => {
  return ndjson.toString('utf8').split('\n').filter(Boolean).map(line => JSON.parse(line));
};

var getHistory = function getHistory(documentIds) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  var time = options.time,
      revision = options.revision;

  if (time && revision) {
    throw new Error("getHistory can't handle both time and revision parameters");
  }

  var dataset = _client.default.clientConfig.dataset;
  var url = "/data/history/".concat(dataset, "/documents/").concat(ids.join(','));

  if (revision) {
    url = "".concat(url, "?revision=").concat(revision);
  } else {
    var timestamp = time || new Date().toISOString();
    url = "".concat(url, "?time=").concat(timestamp);
  }

  return _client.default.request({
    url
  });
};

var getDocumentAtRevision = (documentId, revision) => {
  var cacheKey = "".concat(documentId, "@").concat(revision);

  if (!(cacheKey in documentRevisionCache)) {
    var dataset = _client.default.clientConfig.dataset;
    var url = "/data/history/".concat(dataset, "/documents/").concat(documentId, "?revision=").concat(revision);
    documentRevisionCache[cacheKey] = _client.default.request({
      url
    }).then(result => result.documents[0]);
  }

  return documentRevisionCache[cacheKey];
};

var getTransactions = documentIds => {
  var ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  var dataset = _client.default.clientConfig.dataset;
  var url = "/data/history/".concat(dataset, "/transactions/").concat(ids.join(','), "?excludeContent=true");
  return _client.default.request({
    url
  }).then(ndjsonToArray);
};

function historyEventsFor(documentId) {
  var pairs = [(0, _draftUtils.getDraftId)(documentId), (0, _draftUtils.getPublishedId)(documentId)];
  var query = '*[_id in $documentIds]';
  var pastTransactions$ = (0, _rxjs.from)(getTransactions(pairs)).pipe((0, _operators.mergeMap)(transactions => (0, _rxjs.from)(transactions)), (0, _operators.map)(trans => ({
    author: trans.author,
    documentIDs: pairs,
    id: trans.id,
    mutations: trans.mutations,
    timestamp: trans.timestamp
  })), (0, _operators.reduce)(compileTransactions, {}));

  var realtimeTransactions$ = _client.default.observable.listen(query, {
    documentIds: pairs
  }).pipe((0, _operators.map)(item => ({
    author: item.identity,
    documentIDs: pairs,
    id: item.transactionId,
    mutations: item.mutations,
    timestamp: item.timestamp
  })), (0, _operators.scan)(compileTransactions, {}));

  return (0, _rxjs.merge)(realtimeTransactions$, pastTransactions$).pipe((0, _operators.scan)((prev, next) => {
    return _objectSpread({}, prev, next);
  }, {}), (0, _operators.map)(transactions => (0, _transactionCollator.transactionsToEvents)(pairs, Object.keys(transactions).map(key => transactions[key])).reverse()));
}

function createHistoryStore() {
  return {
    getDocumentAtRevision,
    getHistory,
    getTransactions,
    historyEventsFor
  };
}